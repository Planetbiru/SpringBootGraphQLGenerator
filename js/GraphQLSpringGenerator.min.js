class GraphQLSpringGenerator{constructor(){this.packageName=null,this.groupId=null,this.artifactId=null,this.serviceName=null,this.serviceDescription=null,this.javaVersion=null,this.version=null,this.maxRelationDepth=3,this.model=null,this.selectedModel=null}moveEntityUp(e,t){if(e<this.model.entities.length-1){let a=this.model.entities[e];this.model.entities[e]=this.model.entities[e+1],this.model.entities[e+1]=a,this.updateEntityIndex()}t()}moveEntityDown(e,t){if(e>0){let a=this.model.entities[e];this.model.entities[e]=this.model.entities[e-1],this.model.entities[e-1]=a,this.updateEntityIndex()}t()}updateEntityIndex(){this.model.entities.forEach((e,t)=>{e.index=t})}setModel(e){this.model=e}getModel(){return this.model}status(e){document.querySelector("#status").textContent=e}generateVirtualFiles(){let e={port:parseInt(document.querySelector("#appPort").value.trim(),10)},t={url:document.querySelector("#dbUrl").value.trim(),username:document.querySelector("#dbUsername").value.trim(),password:document.querySelector("#dbPassword").value,driver:document.querySelector("#dbDriver").value.trim(),showSql:"true"===document.querySelector("#dbShowSql").value,dialect:document.querySelector("#dbDialect").value.trim()},a=[];return this.status("Generate pom file"),a.push(...this.generatePomFile(t.url)),this.status("Generate maven file"),a.push(...Maven.generateMavenFile()),this.status("Generate maven.cmd file"),a.push(...Maven.generateMavenCmdFile()),this.status("Generate maven wrapper file"),a.push(...Maven.generateMavenWrapperFiles()),this.status("Generate application file"),a.push(...this.generateApplicationFile()),this.status("Generate application property file"),a.push(...this.generateApplicationPropertiesFile(e,t)),this.status("Generate ID files"),a.push(...this.generateIdClassFiles()),this.status("Generate entity files"),a.push(...this.generateEntityFiles()),this.status("Generate DTO files"),a.push(...this.generateDtoFiles()),this.status("Generate DTO output files"),a.push(...this.generateConnectionFiles()),this.status("Generate repository files"),a.push(...this.generateRepositoryFiles()),this.status("Generate page info file"),a.push(...this.generatePageInfoFile()),this.status("Generate page utility file"),a.push(...this.generatePageUtilFile()),this.status("Generate specification utility file"),a.push(...this.generateSpecificationUtilFile()),this.status("Generate fetch property file"),a.push(...this.generateFetchPropertiesFile()),this.status("Generate data filter file"),a.push(...this.generateDataFilterFile()),this.status("Generate data order file"),a.push(...this.generateDataOrderFile()),this.status("Generate service files"),a.push(...this.generateServiceFiles()),this.status("Generate controller files"),a.push(...this.generateControllerFiles()),this.status("Generate GraphQL schema file"),a.push(...this.generateGraphQlSchema()),this.status("Generate CORS config file"),a.push(...this.generateCorsConfigFile()),this.status("Generate request interceptor file"),a.push(...this.generateRequestInterceptorFile()),a}async createZipFile(e,t={},a="servicegen.zip"){let r=document.querySelector(".progress-bar");r.style.transition="none",r.style.width="0%",r.setAttribute("aria-valuenow",0);let i=this;this.status("Preparing..."),this.packageName=t.packageName||"com.example.servicegen",this.groupId=t.groupId||"com.example",this.artifactId=t.artifactId||"servicegen",this.serviceName=t.serviceName||"Service Generator",this.serviceDescription=t.serviceDescription||"A service generator for Spring GraphQL",this.javaVersion=t.javaVersion||"21",this.version=t.version||"1.0.0",this.maxRelationDepth=3,this.startTime=t.startTime,e?this.selectedModel=e:this.selectedModel=this.model;let n=document.getElementById("loading");n.style.display="block";let o=this.generateVirtualFiles();if(0===o.length){n.style.display="none";return}let s=0,p=new JSZip;for(let l of o)p.file(l.name,l.content),s+=l.content.length;try{i.status("Generating ZIP file...");let c=await p.generateAsync({type:"blob"},e=>{if(e.percent){let t=e.percent.toFixed(2),a=e.currentFile||"";i.status(`${a}`),r.style.width=t+"%",r.setAttribute("aria-valuenow",t)}});i.status(`Finished in ${(new Date-i.startTime)/1e3} seconds (${s} bytes)`),r.style.width="100%",r.setAttribute("aria-valuenow",100),saveAs(c,a)}catch(u){console.error("Error generating ZIP file: ",u)}finally{n.style.display="none"}}getPrimaryKeys(e){return e.columns.filter(e=>e.primaryKey)}getPrimatyKey(e){let t=e.columns.find(e=>e.primaryKey);return t?{primaryKeyName:t.name,primaryKeyCamel:StringUtil.camelize(t.name),primaryKeyType:t.type,primaryKeyJavaType:TypeUtil.getJavaType(t.type)}:null}removeUnusedImports(e){let t=e.split("\n"),a=t.filter(e=>e.trim().startsWith("import ")),r=t.filter(e=>!e.trim().startsWith("import ")).join("\n"),i=[];a.forEach(e=>{let t=e.match(/import\s+([\w\.]+);/);if(t){let a=t[1],n=a.split(".").pop(),o=RegExp("\\b"+n+"\\b");o.test(r)&&i.push(e)}});let n=t.find(e=>e.startsWith("package ")),o=t.filter(e=>!e.startsWith("package ")&&!e.startsWith("import "));return[n,"",...i,"",...o].join("\n").replace(/\n{3,}/g,"\n\n")}createSourceDirectoryFromArtefact(e){return"src/main/java/"+e.split(".").join("/")+"/"}generateApplicationFile(){let e=`package ${this.packageName};

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"Application.java",content:e}]}generateApplicationPropertiesFile(e,t){let a=`# Spring Boot application properties
# Server port
server.port=${e.port||8080}
# Database configuration
spring.datasource.url=${t.url||"jdbc:mysql://localhost:3306/mydb"}
spring.datasource.username=${t.username||"root"}
spring.datasource.password=${t.password||""}
spring.datasource.driver-class-name=${t.driver||"com.mysql.cj.jdbc.Driver"}
# JPA/Hibernate configuration
spring.jpa.show-sql=${t.showSql||"true"}
spring.jpa.properties.hibernate.dialect=${t.dialect}
# GraphQL configuration
spring.graphql.schema-location=classpath:graphql/schema.graphqls
# Logging configuration
logging.level.org.springframework=INFO
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
# Application name and description
spring.application.name=${this.serviceName}
spring.application.description=${this.serviceDescription}
# Java version
spring.java.version=${this.javaVersion}
# Package name
spring.package.name=${this.packageName}
# Version
spring.application.version=${this.version}
`;return[{name:"src/main/resources/application.properties",content:a}]}generateRequestInterceptorFile(){let e=`package ${this.packageName}.config;

import java.net.InetAddress;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import org.springframework.graphql.server.WebGraphQlInterceptor;
import org.springframework.graphql.server.WebGraphQlRequest;
import org.springframework.graphql.server.WebGraphQlResponse;
import org.springframework.stereotype.Component;
import org.springframework.util.MultiValueMap;
import org.springframework.util.MultiValueMapAdapter;

import reactor.core.publisher.Mono;

/**
 * The GraphQLRequestInterceptor is a Spring component that intercepts every GraphQL request.
 * It is responsible for capturing and storing important request metadata such as the client's
 * IP address, HTTP headers, and the raw GraphQL query into the GraphQLContext.
 *
 * By storing this data in the GraphQLContext, it can be accessed by any DataFetcher or
 * resolver during query execution. This enables functionalities like logging, auditing,
 * or context-based validation.
 */
@Component
public class GraphQLRequestInterceptor implements WebGraphQlInterceptor {
    /**
     * Intercepts an incoming GraphQL request and adds metadata to its GraphQLContext.
     *
     * @param request The incoming GraphQL request.
     * @param chain   The interceptor chain used to pass the request along.
     * @return A Mono<WebGraphQlResponse> representing the response after execution.
     */
    @Override
    public Mono<WebGraphQlResponse> intercept(WebGraphQlRequest request, Chain chain) {
        Map<String, String> headers = request.getHeaders().toSingleValueMap();
        String clientIp = Optional.ofNullable(request.getRemoteAddress())
                .map(addr -> addr.getAddress())
                .map(InetAddress::getHostAddress)
                .orElse("UNKNOWN");
        String path = request.getUri().getPath();
        MultiValueMap<String, String> queryParams = request.getUri().getQueryParams();
        
        Map<String, String> queryParamsFlat = Optional.ofNullable(queryParams).orElse(new MultiValueMapAdapter<>(new HashMap<>())).toSingleValueMap();
        
        String graphqlQuery = Optional.ofNullable(request.getDocument()).orElse("");

        Map<String, Object> contextMap = new HashMap<>();
        contextMap.put("clientIp", clientIp);
        contextMap.put("headers", headers);
        contextMap.put("path", path);
        contextMap.put("queryParams", queryParamsFlat);
        contextMap.put("graphqlQuery", graphqlQuery);

        request.configureExecutionInput((executionInput, builder) ->
                builder.graphQLContext(contextMap).build()
        );

        return chain.next(request);
    }
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"config/GraphQLRequestInterceptor.java",content:e}]}generateCorsConfigFile(){let e=`package ${this.packageName}.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/graphql/**") 
                .allowedOrigins("*") 
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("*");
    }
}`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"config/CorsConfig.java",content:e}]}generateControllerFiles(){let e=this.selectedModel.entities,t=[];return e.forEach(e=>{let a=e.name,r=StringUtil.camelize(a),i=StringUtil.upperCamel(e.name),n=this.getPrimaryKeys(e);if(n.length>0){let o=n.map(e=>`@Argument ${TypeUtil.getJavaType(e.type)} ${StringUtil.camelize(e.name)}`).join(", "),s=n.map(e=>StringUtil.camelize(e.name)).join(", "),p=`package ${this.packageName}.controller;

import java.util.List;

import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.graphql.data.method.annotation.MutationMapping;
import org.springframework.stereotype.Controller;

import ${this.packageName}.output.${i}Connection;
import ${this.packageName}.utils.DataFilter;
import ${this.packageName}.utils.DataOrder;
import ${this.packageName}.dto.${i}Create;
import ${this.packageName}.dto.${i}Update;
import ${this.packageName}.entity.${i};
import ${this.packageName}.service.${i}Service;

import graphql.schema.DataFetchingEnvironment;

import lombok.RequiredArgsConstructor;

/**
 * GraphQL Controller for managing ${i}.
 * Provides queries and mutations for retrieving, creating, updating, and deleting ${i} data.
 *
 * Queries:
 * - get${i}s: Retrieve a paginated list of ${i} with optional filtering and ordering.
 * - get${i}: Retrieve details of a single ${i} by ID.
 *
 * Mutations:
 * - create${i}: Create a new ${i}.
 * - update${i}: Update an existing ${i}.
 * - delete${i}: Delete an ${i} by ID.
 */
@Controller
@RequiredArgsConstructor
public class ${i}Controller {

    private final ${i}Service ${r}Service;
    
    /**
     * Retrieves a paginated list of ${i} with optional filtering and ordering.
     *
     * @param pageNumber the page number to retrieve
     * @param pageSize the number of items per page
     * @param dataFilter list of filters to apply
     * @param dataOrder list of ordering rules
     * @param env GraphQL data fetching environment
     * @return ${i}Connection containing the paginated result
     */
    @QueryMapping
    public ${i}Connection get${i}s(@Argument(name = "pageNumber") Integer pageNumber, @Argument(name = "pageSize") Integer pageSize, @Argument(name = "dataFilter") List<DataFilter> dataFilter, @Argument(name = "dataOrder") List<DataOrder> dataOrder, DataFetchingEnvironment env) {
        return ${r}Service.get${i}s(pageNumber, pageSize, dataFilter, dataOrder);
    }

    /**
     * Retrieves details of a single ${i} by its ID.
     *
     * @param anggotaId the ID of the ${i} to retrieve
     * @param env GraphQL data fetching environment
     * @return ${i} entity
     */
    @QueryMapping
    public ${i} get${i}(${o}, DataFetchingEnvironment env) {
        return ${r}Service.get${i}(${s});
    }

    /**
     * Creates a new ${i}.
     *
     * @param input the data for the new ${i}
     * @param env GraphQL data fetching environment
     * @return the created ${i} entity
     */
    @MutationMapping
    public ${i} create${i}(@Argument ${i}Create input, DataFetchingEnvironment env) {
        return ${r}Service.create${i}(input);
    }

    /**
     * Updates an existing ${i}.
     *
     * @param input the updated data for the ${i}
     * @param env GraphQL data fetching environment
     * @return the updated ${i} entity
     */
    @MutationMapping
    public ${i} update${i}(@Argument ${i}Update input, DataFetchingEnvironment env) {
        return ${r}Service.update${i}(input);
    }

    /**
     * Deletes an ${i} by its ID.
     *
     * @param anggotaId the ID of the ${i} to delete
     * @param env GraphQL data fetching environment
     * @return true if deletion was successful
     */
    @MutationMapping
    public Boolean delete${i}(${o}, DataFetchingEnvironment env) {
        ${r}Service.delete${i}(${s});
        return true;
    }
}
`;t.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`controller/${i}Controller.java`,content:p})}}),t}getDataTypeConstant(e){switch(e){case"Long":return"SpecificationUtil.DATA_TYPE_LONG";case"Integer":return"SpecificationUtil.DATA_TYPE_INTEGER";case"Double":return"SpecificationUtil.DATA_TYPE_DOUBLE";case"Float":return"SpecificationUtil.DATA_TYPE_FLOAT";case"Boolean":return"SpecificationUtil.DATA_TYPE_BOOLEAN";case"Date":return"SpecificationUtil.DATA_TYPE_DATE";case"DateTime":return"SpecificationUtil.DATA_TYPE_DATETIME";case"String":return"SpecificationUtil.DATA_TYPE_STRING";default:return""}}getFilterOperationConstant(e){return"partial"===e?"SpecificationUtil.FILTER_OPERATION_PARTIAL":"SpecificationUtil.FILTER_OPERATION_EXACT"}generateServiceFiles(){let e=this,t=this.selectedModel.entities,a=[];return t.forEach(t=>{let r=t.name,i=StringUtil.camelize(r),n=StringUtil.upperCamel(t.name),o=this.getPrimaryKeys(t),s="";if(t.columns.forEach(t=>{let a=TypeUtil.getJavaType(t.type),r=e.getDataTypeConstant(a),i=e.getFilterOperationConstant(e.getFilterType(a)),n=StringUtil.camelize(t.name);s+=`		this.queryPredicateMapping.add("${n}", "${n}", ${r}, ${i});\r
`}),o.length>0){let p=o.map(e=>`${TypeUtil.getJavaType(e.type)} ${StringUtil.camelize(e.name)}`).join(", "),l=o.map(e=>StringUtil.camelize(e.name)).join(", "),c='"'+o.map(e=>StringUtil.camelize(e.name)).join('", "')+'"',u=o.map(e=>StringUtil.upperCamel(e.name)).join("And"),g=[];o.forEach(e=>{let t=StringUtil.upperCamel(e.name);g.push(`input.get${t}() == null`)});let d=`package ${this.packageName}.service;

import java.util.List;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import lombok.RequiredArgsConstructor;

import ${this.packageName}.dto.${n}Create;
import ${this.packageName}.dto.${n}Update;
import ${this.packageName}.entity.${n};
import ${this.packageName}.entity.${n}Input;
import ${this.packageName}.output.${n}Connection;
import ${this.packageName}.repository.${n}Repository;
import ${this.packageName}.repository.${n}InputRepository;
import ${this.packageName}.utils.DataFilter;
import ${this.packageName}.utils.DataOrder;
import ${this.packageName}.utils.QueryPredicateMapping;
import ${this.packageName}.utils.PageUtil;
import ${this.packageName}.utils.SpecificationUtil;

import jakarta.annotation.PostConstruct;
import jakarta.transaction.Transactional;

/**
 * Service class for handling business logic and CRUD operations 
 * for the {@link ${n}} entity.
 *
 * <p>This service provides methods to query, create, update, and delete 
 * records from the database using the associated repository.</p>
 *
 * <p>Generated automatically by GraphQL Generator.</p>
 */
@Service
@RequiredArgsConstructor
public class ${n}Service {

    private final ${n}Repository ${i}Repository;
    private final ${n}InputRepository ${i}InputRepository;

    private QueryPredicateMapping queryPredicateMapping;
    
    @PostConstruct
    public void init()
    {
    	queryPredicateMapping = new QueryPredicateMapping();
    	
${s}
    }
    
    /**
     * Retrieves a paginated and optionally filtered list of {@link ${n}} records from the database.
     * This method supports dynamic filtering and sorting based on the provided criteria,
     * and wraps the result in an {@link ${n}Connection} for pagination support.
     *
     * @param pageNumber the 1-based page number for pagination (required).
     * @param pageSize the number of records to retrieve per page (required).
     * @param dataFilter an optional list of filters to be applied to the query (may be {@code null} or empty).
     * @param dataOrder an optional list of fields and their sort order to be applied to the query (may be {@code null} or empty).
     * @return {@link ${n}Connection} object containing the paginated {@link ${n}} records
     *         that match the given filtering and sorting criteria.
     */
    public ${n}Connection get${n}s(Integer pageNumber, Integer pageSize, List<DataFilter> dataFilter, List<DataOrder> dataOrder) {
        
        Specification<${n}> specification = SpecificationUtil.createSpecificationFromFilter(dataFilter, this.queryPredicateMapping.getFilter());
        
        Pageable pageable = PageUtil.pageRequest(pageNumber, pageSize, dataOrder, this.queryPredicateMapping.getFilter(), Sort.by(Sort.Direction.ASC, ${c}));
        
        Page<${n}> page = ${i}Repository.findAll(
        	specification, 
        	pageable
        );
        return new ${n}Connection(page);
    }

    /**
     * Retrieves ${n} record matching the given primary key.
     *
     * @param ${o.map(e=>StringUtil.camelize(e.name)).join(", ")} the primary key value(s) used for filtering.
     * @return a list of matching ${n} entities.
     */
    public ${n} get${n}(${p}) {
        return ${i}Repository.findOneBy${u}(${l});
    }

    /**
     * Creates a new record for {@link ${n}} in the database.
     *
     * @param input the ${n} entity to be created.
     * @return the saved ${n} entity.
     */
    public ${n} create${n}(${n}Create input) {
        ${n}Input saved = ${i}InputRepository.save(${n}Create.createEntity(input));
        return ${i}Repository.findOneBy${u}(
            ${o.map(e=>`saved.get${StringUtil.upperCamel(e.name)}()`).join(", ")}
        );
    }

    /**
     * Updates an existing {@link ${n}} record in the database.
     *
     * @param input the ${n} entity containing updated values.
     * @return the updated ${n} entity.
     */
    public ${n} update${n}(${n}Update input) {
        if(${g.join(" || ")})
    	{
    		return null;
    	}
        ${n}Input saved = ${i}InputRepository.save(${n}Update.createEntity(input));
        return ${i}Repository.findOneBy${u}(
            ${o.map(e=>`saved.get${StringUtil.upperCamel(e.name)}()`).join(", ")}
        );
    }

    /**
     * Deletes the {@link ${n}} record that matches the given primary key(s).
     *
     * @param ${o.map(e=>StringUtil.camelize(e.name)).join(", ")} the primary key value(s) of the record to delete.
     */
    @Transactional
    public void delete${n}(${p}) {
        ${i}InputRepository.deleteBy${u}(${l});
    }
}
`;a.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`service/${n}Service.java`,content:d})}}),a}gereratePageUtilFile(){let e=`package ${this.packageName}.utils;

import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;

public class PageUtil {

    /**
     * Creates a Pageable object for paginated and sorted queries.
     *
     * @param pageNumber The 1-based page number. Defaults to 1 if null or less than 1.
     * @param pageSize The number of items per page. Defaults to 20, min is 1.
     * @param orderByFields An array of field names to sort by. Defaults to ascending.
     * @return A Pageable object configured with pagination and sorting.
     */
    public static Pageable pageRequest(Integer pageNumber, Integer pageSize, String... orderByFields) {
        // Handle page number: convert to 0-based and ensure it's not negative.
        int currentPage = (pageNumber != null && pageNumber > 0) ? pageNumber - 1 : 0;
        
        // Handle page size: ensure it's at least 1.
        int rowPerPage = (pageSize != null && pageSize > 0) ? pageSize : 20;

        // Create Sort object if orderByFields are provided
        Sort sort = Sort.unsorted();
        if (orderByFields != null && orderByFields.length > 0) {
            sort = Sort.by(Direction.ASC, orderByFields);
        }
        
        return PageRequest.of(currentPage, rowPerPage, sort);
    }
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/PageUtil.java",content:e}]}generateSpecificationUtilFile(){let e=`package ${this.packageName}.utils;

import jakarta.persistence.criteria.Path;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.Root;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.text.ParseException;
import java.util.HashMap;

import org.springframework.data.jpa.domain.Specification;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Utility class for creating dynamic JPA Specifications from DataFilters.
 * This class provides a generic method that can be used for any entity type.
 */
public class SpecificationUtil {

    private SpecificationUtil() {
        // Hide public constructor
    }

    public static final String DATA_TYPE_LONG = "Long";
    public static final String DATA_TYPE_INTEGER = "Integer";
    public static final String DATA_TYPE_DOUBLE = "Double";
    public static final String DATA_TYPE_FLOAT = "Float";
    public static final String DATA_TYPE_BOOLEAN = "Boolean";
    public static final String DATA_TYPE_DATE = "Date";
    public static final String DATA_TYPE_DATETIME = "DateTime";
    public static final String DATA_TYPE_STRING = "String";

    public static final String FILTER_OPERATION_EXACT = "exact";
    public static final String FILTER_OPERATION_PARTIAL = "partial";

    public static final String DATE_FORMAT = "yyyy-MM-dd";
    public static final String DATETIME_FORMAT = "yyyy-MM-dd'T'HH:mm:ss";

    public static final String REGEX_INTEGER = "^-?\\\\d+$";
    public static final String REGEX_FLOAT   = "^-?\\\\d+(\\\\.\\\\d+)?$";
    public static final String REGEX_BOOLEAN = "^(?i:true|false)$";

    private static final Logger logger = LoggerFactory.getLogger(SpecificationUtil.class);

    /**
     * Converts a list of {@link DataFilter} objects into a {@link Map}.
     * <p>
     * Each entry in the resulting map uses the filter's field name as the key
     * and the filter's field value as the value. Filters with a {@code null}
     * field name are ignored.
     * </p>
     *
     * @param dataFilter the list of filters; may be {@code null} or empty
     * @return a non-null {@link Map} where keys are field names and values are the
     *         corresponding field values; may be empty if no valid filters are provided
     */
    public static Map<String, Object> getFilterFromRequest(List<DataFilter> dataFilter) {
        Map<String, Object> result = new HashMap<>();
        if (dataFilter == null || dataFilter.isEmpty()) {
            return result;
        }
        for (DataFilter filter : dataFilter) {
            String key = filter.getFieldName();
            Object fieldValue = filter.getFieldValue();
            if (key != null) {
                result.put(key, fieldValue);
            }
        }
        return result;
    }

    /**
     * Creates a generic {@link Specification} from a list of {@link DataFilter} to build dynamic queries.
     * This method supports various filtering types based on the provided filterOperation map.
     *
     * @param dataFilter list of filters to apply.
     * @param filters a map defining the data type and filter type for each field.
     * @param <T> The entity type to be filtered.
     * @return a Specification object representing the combined filters.
     */
    public static <T> Specification<T> createSpecificationFromFilter(List<DataFilter> dataFilter, Map<String, Map<String, String>> filters) {
        if (dataFilter == null || dataFilter.isEmpty() || filters == null) {
            return null;
        }

        Optional<Specification<T>> spec = Optional.empty();

        for (DataFilter filter : dataFilter) {
            String key = filter.getFieldName();
            Object fieldValue = filter.getFieldValue();
            String valueStr = String.valueOf(fieldValue);

            if (key != null && fieldValue != null) {
                Map<String, String> fieldInfo = filters.get(key);

                if (fieldInfo != null) {
                    String fieldName = fieldInfo.get("fieldName");
                    String dataType = fieldInfo.get("dataType");
                    String filterOperation = fieldInfo.get("filterOperation");

                    Specification<T> currentSpec = (root, query, criteriaBuilder) -> {
                        try {
                            Path<?> path = resolvePath(root, fieldName);
                            
                            switch (dataType) {
                                case DATA_TYPE_LONG:
                                    return criteriaBuilder.equal(path, Long.parseLong(valueStr));
                                case DATA_TYPE_INTEGER:
                                    return criteriaBuilder.equal(path, Integer.parseInt(valueStr));
                                case DATA_TYPE_DOUBLE:
                                case DATA_TYPE_FLOAT:
                                    return criteriaBuilder.equal(path, Double.parseDouble(valueStr));
                                case DATA_TYPE_BOOLEAN:
                                    return criteriaBuilder.equal(path, Boolean.parseBoolean(valueStr));
                                case DATA_TYPE_DATE:
                                    Date date = new SimpleDateFormat(DATE_FORMAT).parse(valueStr);
                                    return criteriaBuilder.equal(path, date);
                                case DATA_TYPE_DATETIME:
                                    Date dateTime = new SimpleDateFormat(DATETIME_FORMAT).parse(valueStr);
                                    return criteriaBuilder.equal(path, dateTime);
                                case DATA_TYPE_STRING:
                                    if (FILTER_OPERATION_EXACT.equals(filterOperation)) {
                                        return criteriaBuilder.equal(path, fieldValue);
                                    } else if (FILTER_OPERATION_PARTIAL.equals(filterOperation)) {
                                        return criteriaBuilder.like(criteriaBuilder.lower((Path<String>) path), "%" + valueStr.toLowerCase() + "%");
                                    }
                                    break;
                                default:
                                    logger.warn("Unsupported data type: {}", dataType);
                                    return null;
                            }
                        } catch (ParseException e) {
                            logger.error("Error parsing date/datetime for field {}: {}", fieldName, e.getMessage());
                        } catch (Exception e) {
                            logger.error("Error creating predicate for field {}: {}", fieldName, e.getMessage());
                        }
                        return criteriaBuilder.disjunction(); // Return a false predicate on error
                    };

                    spec = Optional.of(spec.map(s -> s.and(currentSpec)).orElse(currentSpec));
                }
            }
        }
        return spec.orElse(null);
    }

    /**
     * Retrieves a {@link Date} value from the map using the specified key.
     * Parsed with {@code yyyy-MM-dd}.
     */
    public static Date getDate(Map<String, Object> map, String key) throws ParseException {
        String valueStr = getString(map, key);
        if (valueStr == null) return null;
        return new SimpleDateFormat(DATE_FORMAT).parse(valueStr);
    }

    /**
     * Retrieves a {@link Date} value with time from the map using the specified key.
     * Parsed with {@code yyyy-MM-dd HH:mm:ss}.
     */
    public static Date getDateTime(Map<String, Object> map, String key) throws ParseException {
        String valueStr = getString(map, key);
        if (valueStr == null) return null;
        return new SimpleDateFormat(DATETIME_FORMAT).parse(valueStr);
    }

    /**
     * Retrieves a {@link Long} value.
     */
    @SuppressWarnings("UnnecessaryTemporaryOnConversionFromString")
    public static Long getLong(Map<String, Object> map, String key) {
        String valueStr = getString(map, key);
        if (valueStr == null || !valueStr.matches(REGEX_INTEGER)) return null;
        return Long.parseLong(valueStr);
    }

    /**
     * Retrieves an {@link Integer} value.
     */
    @SuppressWarnings("UnnecessaryTemporaryOnConversionFromString")
    public static Integer getInteger(Map<String, Object> map, String key) {
        String valueStr = getString(map, key);
        if (valueStr == null || !valueStr.matches(REGEX_INTEGER)) return null;
        return Integer.parseInt(valueStr);
    }

    /**
     * Retrieves a {@link Double} value.
     */
    @SuppressWarnings("UnnecessaryTemporaryOnConversionFromString")
    public static Double getDouble(Map<String, Object> map, String key) {
        String valueStr = getString(map, key);
        if (valueStr == null || !valueStr.matches(REGEX_FLOAT)) return null;
        return Double.parseDouble(valueStr);
    }

    /**
     * Retrieves a {@link Float} value.
     */
    @SuppressWarnings("UnnecessaryTemporaryOnConversionFromString")
    public static Float getFloat(Map<String, Object> map, String key) {
        String valueStr = getString(map, key);
        if (valueStr == null || !valueStr.matches(REGEX_FLOAT)) return null;
        return Float.parseFloat(valueStr);
    }

    /**
     * Retrieves a {@link Boolean} value.
     * Only accepts "true" or "false" (case-insensitive).
     */
    @SuppressWarnings({
        "UnnecessaryTemporaryOnConversionFromString",
        "DataFlowIssue"
    })
    public static Boolean getBoolean(Map<String, Object> map, String key) {
        String valueStr = getString(map, key);
        if (valueStr == null || !valueStr.matches(REGEX_BOOLEAN)) return null;
        return Boolean.parseBoolean(valueStr);
    }

    /**
     * Safely retrieves a trimmed String value from map.
     * Returns null if value is missing, blank, or equals "null".
     */
    private static String getString(Map<String, Object> map, String key) {
        if (map == null || key == null || !map.containsKey(key)) {
            return null;
        }
        Object value = map.get(key);
        if (value == null) return null;
        String valueStr = String.valueOf(value).trim();
        return valueStr.isEmpty() || "null".equalsIgnoreCase(valueStr) ? null : valueStr;
    }

    /**
     * Helper method to resolve a nested path by performing joins.
     * This method handles both direct attributes and nested attributes with multiple dots.
     *
     * @param root The root of the query.
     * @param fieldName The dot-separated field name (e.g., "album.artist.name").
     * @return The final Path object to the attribute.
     */
    private static Path<?> resolvePath(Root<?> root, String fieldName) {
        String[] parts = fieldName.split("\\\\\\\\.");
        Path<?> path = root;

        // Iterate through all parts of the path
        for (int i = 0; i < parts.length - 1; i++) {
            // Cast to Join is needed to continue the path, but only if the current path is not the root
            if (path instanceof Root) {
                 path = ((Root<?>) path).join(parts[i]);
            } else {
                 path = ((Join<?, ?>) path).join(parts[i]);
            }
        }
        
        // Return the final Path to the attribute
        return path.get(parts[parts.length - 1]);
    }
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/SpecificationUtil.java",content:e}]}generateDataFilterFile(){let e=`package ${this.packageName}.utils;

import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
public class DataFilter {
	String fieldName;
	String fieldValue;
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/DataFilter.java",content:e}]}generateDataOrderFile(){let e=`package ${this.packageName}.utils;

import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
public class DataOrder {
	String fieldName;
	String orderType;
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/DataOrder.java",content:e}]}getNestedRelations(e,t,a="",r=2){if(r<=0)return[];let i=[],n=this.getPrimaryKeys(t).length>1;return t.columns.forEach(o=>{if(this.isForeignKey(e,t,o)&&!n){let s=StringUtil.camelize(o.name.replace(/_id$/i,"")),p=a?`${a}.${s}`:s;i.push(p);let l=e.find(e=>e.name.toLowerCase()===s.toLowerCase());l&&i.push(...this.getNestedRelations(e,l,p,r-1))}}),t.columns.forEach(t=>{if(n){let o=StringUtil.camelize(t.name.replace(/_id$/i,"")),s=a?`${a}.${o}`:o;i.push(s);let p=e.find(e=>e.name.toLowerCase()===o.toLowerCase());p&&i.push(...this.getNestedRelations(e,p,s,r-1))}}),i}generateConnectionFiles(){let e=this.selectedModel.entities,t=[];return e.forEach(e=>{let a=StringUtil.upperCamel(e.name),r=`package ${this.packageName}.output;

import org.springframework.data.domain.Page;

import ${this.packageName}.entity.${a};
import ${this.packageName}.utils.PageInfo;

/**
 * A connection wrapper for paginated {@link ${a}} results.
 * <p>
 * This class encapsulates both the paginated list of {@link ${a}} entities
 * and pagination metadata via {@link PageInfo}.
 * It is commonly used as a GraphQL-compatible representation of
 * paginated query results.
 * </p>
 */
public class ${a}Connection
{
    /**
     * Pagination metadata, including total records, total pages,
     * current page number, and page size.
     */
    PageInfo pageInfo;

    /**
     * The underlying paginated data of {@link ${a}} entities.
     */
    Page<${a}> data;

    /**
     * Constructs a new {@code ${a}Connection} from a Spring Data {@link Page}.
     * <p>
     * The {@link PageInfo} is initialized from the provided {@link Page}
     * to represent pagination details.
     * </p>
     *
     * @param page the {@link Page} of {@link ${a}} entities to wrap.
     */
    public ${a}Connection(Page<${a}> page)
    {
        this.data = page;
        this.pageInfo = new PageInfo(page);
    }
}

`;t.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`output/${a}Connection.java`,content:r})}),t}generateRepositoryFiles(){let e=this.selectedModel.entities,t=[],a=this;return e.forEach(r=>{let i=StringUtil.camelize(r.name),n=StringUtil.ucfirst(i),o=this.getPrimaryKeys(r);if(o.length>0){let s=o.length>1?`${n}Id`:TypeUtil.getJavaType(o[0].type),p=o.map(e=>StringUtil.upperCamel(e.name)).join("And"),l=o.map(e=>`${TypeUtil.getJavaType(e.type)} ${StringUtil.camelize(e.name)}`).join(", "),c="";["String","Long","Integer","Double","Float","Boolean","Character","Byte","Short"].includes(s)||s.includes(".")||(c=`import ${this.packageName}.entity.${s};
`);let u=this.getNestedRelations(e,r,"",a.maxRelationDepth||3),g="";(u.length>0||o.length>1)&&(g=`    @EntityGraph(attributePaths = { ${u.map(e=>`"${e}"`).join(", ")} })
`);let d=`package ${this.packageName}.repository;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
${u.length>0?"import org.springframework.data.jpa.repository.EntityGraph;\n":""}
import ${this.packageName}.entity.${n};
${c}
/**
 * Repository interface for {@link ${n}} entity.
 * <p>Provides basic CRUD operations and custom queries.</p>
 */
@Repository
public interface ${n}Repository extends JpaRepository<${n}, ${s}> {

${g}    ${n} findOneBy${p}(${l});

${g}    Page<${n}> findAll(Specification<${n}> specification, Pageable pageable);
}
`;t.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`repository/${n}Repository.java`,content:d});let m=`package ${this.packageName}.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import ${this.packageName}.entity.${n}Input;
${c}
/**
 * Repository interface for {@link ${n}Input} entity.
 * <p>Provides basic CRUD operations and custom queries for input version.</p>
 */
@Repository
public interface ${n}InputRepository extends JpaRepository<${n}Input, ${s}> {

    ${n}Input findOneBy${p}(${l});

    void deleteBy${p}(${l});
}
`;t.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`repository/${n}InputRepository.java`,content:m})}}),t}generateEntityFiles(){let e=this,t=this.selectedModel.entities,a=[];return t.forEach(t=>{let r=t.name,i=StringUtil.upperCamel(r),n=StringUtil.snakeize(r),o=this.getPrimaryKeys(t),s=`package ${this.packageName}.entity;

import java.util.Date;
import java.util.UUID;
import java.math.BigDecimal;
import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.IdClass;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PostLoad;
import jakarta.persistence.Table;

import lombok.Setter;
import lombok.Getter;

/**
 * Entity class representing the ${r} table in the database.
 * 
 * <p>This class is automatically generated by GraphQL Generator.</p>
 * <p>Contains fields for each column in the table, with appropriate annotations for JPA.</p>
 */
@Entity
@Table(name = "${n}")
@Setter
@Getter
`;o.length>1&&(s+=`@IdClass(${i}Id.class)
`),s+=`public class ${i} {

`;let p=[];t.columns.forEach(a=>{let r=a.name,i=StringUtil.camelize(r),n=a.type,l=TypeUtil.getJavaType(n),c=i.substring(0,i.length-2),u=StringUtil.ucfirst(c);if(a.primaryKey&&(s+=`    @Id
`,a.autoIncrement&&(s+=`    @GeneratedValue(strategy = GenerationType.IDENTITY)
`)),e.isForeignKey(e.model.entities,t,a)){s+=`    @Column(name = "${r}")
    ${l} ${i};

`;s+=`    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "${a.name}", referencedColumnName = "${a.name}", insertable=false, updatable=false)
    ${u} ${c};

`,p.push({name:c,type:u})}else s+=`    @Column(name = "${r}")
    ${l} ${i};

`;o.length>1&&a.primaryKey&&!a.autoIncrement&&(s+=`    @ManyToOne
    @JoinColumn(name = "${r}", referencedColumnName = "${r}", insertable = false, updatable = false)
    ${u} ${c};

`)}),p.length>0&&(s+=`
    @PostLoad
    public void initRelationsIfNull() {
`,p.forEach(e=>{s+=`        if (this.${e.name} == null) {
            this.${e.name} = new ${e.type}();
        }
`}),s+=`    }
`),s+=`}
`,s=this.removeUnusedImports(s),a.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`entity/${i}.java`,content:s});let l=`package ${this.packageName}.entity;

import java.util.Date;
import java.util.UUID;
import java.math.BigDecimal;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.IdClass;
import jakarta.persistence.Table;

import lombok.Setter;
import lombok.Getter;

/**
 * Entity class representing the ${r} table in the database.
 * 
 * <p>This class is automatically generated by GraphQL Generator.</p>
 * <p>Contains fields for each column in the table, with appropriate annotations for JPA.</p>
 */
@Entity
@Table(name = "${n}")
@Setter
@Getter
`;o.length>1&&(l+=`@IdClass(${i}Id.class)
`),l+=`public class ${i}Input {

`,t.columns.forEach(e=>{let t=e.name,a=StringUtil.camelize(t),r=e.type,i=TypeUtil.getJavaType(r);e.primaryKey&&(l+=`    @Id
`,e.autoIncrement&&(l+=`    @GeneratedValue(strategy = GenerationType.IDENTITY)
`)),l+=`    @Column(name = "${t}")
    ${i} ${a};

`}),l+=`}
`,l=this.removeUnusedImports(l),a.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`entity/${i}Input.java`,content:l})}),a}generateDtoFiles(){let e=this.selectedModel.entities,t=[];return e.forEach(e=>{let a=e.name,r=StringUtil.upperCamel(a),i=StringUtil.snakeize(a),n=`package ${this.packageName}.dto;

import java.util.Date;
import java.util.UUID;
import java.math.BigDecimal;

import lombok.Setter;
import lombok.Getter;

import org.springframework.beans.BeanUtils;

import ${this.packageName}.entity.${r}Input;

/**
 * Data Transfer Object (DTO) for creating a new ${r} entity.
 *
 * <p>This class is automatically generated by GraphQL Generator.</p>
 *
 * <p>It represents the input fields required by the CREATE mutation of the
 * {@code ${i}} table. The DTO can be converted into an {@link ${r}Input}
 * entity using the {@link #createEntity(${r}Create)} factory method.</p>
 */
@Setter
@Getter
`;n+=`public class ${r}Create {

`,e.columns.forEach(e=>{let t=e.name,a=StringUtil.camelize(t),r=e.type,i=TypeUtil.getJavaType(r);e.autoIncrement||(n+=`    ${i} ${a};
`)}),n+=`\r
    /**
     * Converts this DTO into a new {@link ${r}Input} entity.
     *
     * @param dto the {@code ${r}Create} DTO to convert
     * @return a new {@code ${r}Input} entity populated with values from the DTO
     */
    public static ${r}Input createEntity(${r}Create dto) {
        ${r}Input entity = new ${r}Input();
        BeanUtils.copyProperties(dto, entity);
        return entity;
    }
`,n+=`}
`,n=this.removeUnusedImports(n),t.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`dto/${r}Create.java`,content:n});let o=`package ${this.packageName}.dto;

import java.util.Date;
import java.util.UUID;
import java.math.BigDecimal;

import lombok.Setter;
import lombok.Getter;

import org.springframework.beans.BeanUtils;

import ${this.packageName}.entity.${r}Input;

/**
 * Data Transfer Object (DTO) for updating an existing ${r} entity.
 *
 * <p>This class is automatically generated by GraphQL Generator.</p>
 *
 * <p>It represents the input fields required by the UPDATE mutation of the
 * {@code ${i}} table. The DTO can be converted into an {@link ${r}Input}
 * entity using the {@link #createEntity(${r}Create)} factory method.</p>
 */
@Setter
@Getter
`;o+=`public class ${r}Update {

`,e.columns.forEach(e=>{let t=e.name,a=StringUtil.camelize(t),r;o+=`    ${TypeUtil.getJavaType(e.type)} ${a};
`}),o+=`\r
    /**
     * Converts this DTO into a new {@link ${r}Input} entity.
     *
     * @param dto the {@code ${r}Update} DTO to convert
     * @return a new {@code ${r}Input} entity populated with values from the DTO
     */
    public static ${r}Input createEntity(${r}Update dto) {
        ${r}Input entity = new ${r}Input();
        BeanUtils.copyProperties(dto, entity);
        return entity;
    }
`,o+=`}
`,o=this.removeUnusedImports(o),t.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`dto/${r}Update.java`,content:o})}),t}generateFetchPropertiesFile(){let e=`package ${this.packageName}.utils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import lombok.Getter;
import lombok.Setter;

/**
 * A utility class to manage and filter properties for data fetching operations.
 * It stores configurations for filtering and ordering fields, and provides
 * methods to ensure that requested fields are valid and supported.
 */
@Getter
@Setter
public class QueryPredicateMapping {
	
	private Map<String, Map<String, String>> filter;
	private List<Map<String, String>> order;
	
	public QueryPredicateMapping()
	{
		this.filter = new HashMap<>();
		this.order = new ArrayList<>();
	}

	/**
	 * Adds a field to the filter configuration.
	 *
	 * @param key The unique key for the filter (e.g., a field name).
	 * @param fieldName The actual name of the field in the entity.
	 * @param dataType The data type of the field (e.g., "String", "Long").
	 * @param filterOperation The type of filter operation (e.g., "exact", "partial").
	 */
	public void add(String key, String fieldName, String dataType, String filterOperation) {
		this.filter.put(key, this.createFilterType(fieldName, dataType, filterOperation));
	}

	/**
	 * Creates a map representing a single filter type configuration.
	 *
	 * @param fieldName The name of the field.
	 * @param dataType The data type of the field.
	 * @param filterOperation The filter operation type.
	 * @return A map containing the filter properties.
	 */
	private Map<String, String> createFilterType(String fieldName, String dataType, String filterOperation) {
		Map<String, String> field = new HashMap<>();
		
		field.put("fieldName", fieldName);
		field.put("dataType", dataType);
		field.put("filterOperation", filterOperation);
		
		return field;
	}

	/**
	 * Filters a list of data orders to include only those fields that are
	 * configured for filtering in this utility.
	 *
	 * @param dataOrder The list of data orders to filter.
	 * @return A new list containing only the valid data orders.
	 */
	public List<DataOrder> filterFieldName(List<DataOrder> dataOrder) {
		if(dataOrder == null)
		{
			return dataOrder;
		}
		List<DataOrder> result = new ArrayList<>();
		for(DataOrder item : dataOrder)
		{
			if(this.inList(item))
			{
				result.add(item);
			}
		}
		
		return result;
	}
	
	/**
	 * Checks if a given data order field is present in the configured filter list.
	 *
	 * @param order The DataOrder object to check.
	 * @return {@code true} if the field is in the filter list, {@code false} otherwise.
	 */
	public boolean inList(DataOrder order)
	{
		for(Entry<String, Map<String, String>> entry : this.filter.entrySet())
		{
			if(entry.getValue().getOrDefault("fieldName", "").equals(order.getFieldName()))
			{
				return true;
			}
		}
		return false;
	}
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/QueryPredicateMapping.java",content:e}]}generatePageUtilFile(){let e=`package ${this.packageName}.utils;

import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.data.domain.Sort.Order;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;

public class PageUtil {
    
    private PageUtil()
    {
        // Hide public constructor
    }

    /**
     * Creates a Pageable object for paginated and sorted queries.
     *
     * @param pageNumber The 1-based page number. Defaults to 1 if null or less than 1.
     * @param pageSize The number of items per page. Defaults to 20, min is 1.
     * @param sortFields A list of DataOrder objects to sort by.
     * @param map A map to resolve the actual field names from the given keys.
     * @param defaultSortOrder An array of Sort objects to use as the default sort order.
     * @return A Pageable object configured with pagination and sorting.
     */
    public static Pageable pageRequest(Integer pageNumber, Integer pageSize, List<DataOrder> sortFields, Map<String, Map<String, String>> map, Sort... defaultSortOrder) {
        // Handle page number: convert to 0-based and ensure it's not negative.
        int currentPage = (pageNumber != null && pageNumber > 0) ? pageNumber - 1 : 0;
        
        // Handle page size: ensure it's at least 1.
        int rowPerPage = (pageSize != null && pageSize > 0) ? pageSize : 20;
        
        Sort sort = createSortFromList(sortFields, map);

        if (sort.isUnsorted() && defaultSortOrder != null && defaultSortOrder.length > 0) {
            // Correct way to combine multiple Sort objects
            Sort defaultSort = defaultSortOrder[0];
            for (int i = 1; i < defaultSortOrder.length; i++) {
                defaultSort = defaultSort.and(defaultSortOrder[i]);
            }
            sort = defaultSort;
        }
        
        return PageRequest.of(currentPage, rowPerPage, sort);
    }
    
    /**
     * Creates a {@link Sort} object from a list of {@link DataOrder} objects.
     *
     * @param sortFields A list of DataOrder objects, with each object containing "fieldName" and "sortType".
     * @param map A map to resolve the actual field names from the given keys.
     * @return a Sort object representing the combined sorting criteria.
     */
    public static Sort createSortFromList(List<DataOrder> sortFields, Map<String, Map<String, String>> map) {
        if (sortFields == null || sortFields.isEmpty()) {
            return Sort.unsorted();
        }

        List<Order> orders = new ArrayList<>();
        for (DataOrder field : sortFields) {
            String key = field.getFieldName();
            String orderType = field.getOrderType();
            
            // Default to "asc" if no order type is provided
            if (orderType == null) {
                orderType = "asc";
            }

            if (key != null) {
                Map<String, String> orderInfo = map.get(key);
                if (orderInfo != null) {
                    String fieldName = orderInfo.get("fieldName");
                    Direction direction = "desc".equalsIgnoreCase(orderType) ? Direction.DESC : Direction.ASC;
                    orders.add(new Order(direction, fieldName));
                }
            }
        }
        
        if (orders.isEmpty()) {
            return Sort.unsorted();
        }

        return Sort.by(orders);
    }
}
`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/PageUtil.java",content:e}]}isForeignKey(e,t,a){if(a.primaryKey)return!1;for(let r of e){if(r.name===t.name)continue;let i=this.getPrimaryKeys(r);for(let n of i)if(n.name===a.name)return!0}return!1}generateIdClassFiles(){let e=[];return this.model.entities.forEach(t=>{let a=this.getPrimaryKeys(t);if(a.length>1){let r=`${StringUtil.upperCamel(t.name)}Id`,i=`package ${this.packageName}.entity;

import java.io.Serializable;
import java.util.Objects;
import jakarta.persistence.Embeddable;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;

import lombok.Setter;
import lombok.Getter;

@Embeddable
@Setter
@Getter
public class ${r} implements Serializable {

`;a.forEach(e=>{let t=StringUtil.camelize(e.name),a=TypeUtil.getJavaType(e.type);e.primaryKey&&(i+="",e.autoIncrement&&(i+=`    @GeneratedValue(strategy = GenerationType.IDENTITY)
`)),i+=`    ${a} ${t};

`}),i+=`    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ${r} that = (${r}) o;
        return ${a.map(e=>`Objects.equals(${StringUtil.camelize(e.name)}, that.${StringUtil.camelize(e.name)})`).join(" && ")};
    }

    @Override
    public int hashCode() {
        return Objects.hash(${a.map(e=>StringUtil.camelize(e.name)).join(", ")});
    }

`,i+=`}
`,e.push({name:this.createSourceDirectoryFromArtefact(this.packageName)+`entity/${r}.java`,content:i})}}),e}generateGraphQlSchema(){return[{name:"src/main/resources/graphql/schema.graphqls",content:util.buildGraphQLSchema(this.model.entities,!1)}]}generatePageInfoFile(){let e=`package ${this.packageName}.utils;

import lombok.Getter;
import lombok.Setter;

import org.springframework.data.domain.Page;

@Setter
@Getter
public class PageInfo {
	Integer totalCount;
    Integer totalPages;
    Integer currentPage;
    Integer pageSize;
    Boolean hasNextPage; 
    Boolean hasPreviousPage;

	public PageInfo(Page<?> page)
	{
		this.totalCount = page.getNumberOfElements();
		this.totalPages = page.getTotalPages();
		this.currentPage = page.getNumber() + 1;
		this.pageSize = page.getSize();
		this.hasNextPage = page.hasNext();
		this.hasPreviousPage = page.hasPrevious();
	}
}



`;return[{name:this.createSourceDirectoryFromArtefact(this.packageName)+"utils/PageInfo.java",content:e}]}generatePomFile(e){let t={groupId:this.groupId,artifactId:this.artifactId,version:this.version,name:this.serviceName,description:this.serviceDescription,javaVersion:this.javaVersion,packageName:this.packageName},{dependency:a}=this.getDriverAndDialect(e),r=[a].map(e=>{let t=[`	<dependency>`,`		<groupId>${e.groupId}</groupId>`,`		<artifactId>${e.artifactId}</artifactId>`];return e.version&&t.push(`		<version>${e.version}</version>`),e.scope&&t.push(`		<scope>${e.scope}</scope>`),e.optional&&t.push(`		<optional>true</optional>`),t.push(`	</dependency>`),t.join("\n")}).join("\n\n"),i=`<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion>
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.5.4</version>
    <relativePath/> <!-- lookup parent from repository -->
</parent>
<groupId>${t.groupId}</groupId>
<artifactId>${t.artifactId}</artifactId>
<version>${t.version}</version>
<name>${t.name}</name>
<description>${t.description}</description>
<url/>
<licenses>
    <license/>
</licenses>
<developers>
    <developer/>
</developers>
<scm>
    <connection/>
    <developerConnection/>
    <tag/>
    <url/>
</scm>
<properties>
    <java.version>${t.javaVersion}</java.version>
</properties>
<dependencies>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-web</artifactId>
	</dependency>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-data-jpa</artifactId>
	</dependency>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-graphql</artifactId>
	</dependency>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-webflux</artifactId>
	</dependency>

${r}

	<dependency>
		<groupId>org.projectlombok</groupId>
		<artifactId>lombok</artifactId>
		<optional>true</optional>
	</dependency>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-test</artifactId>
		<scope>test</scope>
	</dependency>
	<dependency>
		<groupId>io.projectreactor</groupId>
		<artifactId>reactor-test</artifactId>
		<scope>test</scope>
	</dependency>
</dependencies>

<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <configuration>
                <annotationProcessorPaths>
                    <path>
                        <groupId>org.projectlombok</groupId>
                        <artifactId>lombok</artifactId>
                    </path>
                </annotationProcessorPaths>
            </configuration>
        </plugin>
        <plugin>
            <groupId>io.github.deweyjose</groupId>
            <artifactId>graphqlcodegen-maven-plugin</artifactId>
            <version>1.61.5</version>
            <executions>
                <execution>
                    <id>dgs-codegen</id>
                    <goals>
                        <goal>generate</goal>
                    </goals>
                    <configuration>
                        <schemaPaths>
                            <param>src/main/resources/graphql</param>
                        </schemaPaths>
                        <packageName>${t.packageName}.codegen</packageName>
                        <addGeneratedAnnotation>true</addGeneratedAnnotation>
                        <disableDatesInGeneratedAnnotation>true</disableDatesInGeneratedAnnotation>
                    </configuration>
                </execution>
            </executions>
        </plugin>
        <plugin>
            <groupId>org.codehaus.mojo</groupId>
            <artifactId>build-helper-maven-plugin</artifactId>
            <executions>
                <execution>
                    <id>add-dgs-source</id>
                    <phase>generate-sources</phase>
                    <goals>
                        <goal>add-source</goal>
                    </goals>
                    <configuration>
                        <sources>
                            <source>\${project.build.directory}/generated-sources</source>
                        </sources>
                    </configuration>
                </execution>
            </executions>
        </plugin>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <excludes>
                    <exclude>
                        <groupId>org.projectlombok</groupId>
                        <artifactId>lombok</artifactId>
                    </exclude>
                </excludes>
            </configuration>
        </plugin>
    </plugins>
</build>

</project>
`;return[{name:"pom.xml",content:i}]}getDriverAndDialect(e){return e.startsWith("jdbc:mysql:")?{driver:"com.mysql.cj.jdbc.Driver",dialect:"org.hibernate.dialect.MySQL8Dialect",dependency:{groupId:"com.mysql",artifactId:"mysql-connector-j",scope:"runtime"}}:e.startsWith("jdbc:mariadb:")?{driver:"org.mariadb.jdbc.Driver",dialect:"org.hibernate.dialect.MariaDBDialect",dependency:{groupId:"org.mariadb.jdbc",artifactId:"mariadb-java-client",version:"3.5.1"}}:e.startsWith("jdbc:postgresql:")?{driver:"org.postgresql.Driver",dialect:"org.hibernate.dialect.PostgreSQLDialect",dependency:{groupId:"org.postgresql",artifactId:"postgresql",version:"42.7.4"}}:e.startsWith("jdbc:sqlite:")?{driver:"org.sqlite.JDBC",dialect:"org.hibernate.dialect.SQLiteDialect",dependency:{groupId:"org.xerial",artifactId:"sqlite-jdbc",version:"3.45.1.0"}}:e.startsWith("jdbc:oracle:")?{driver:"oracle.jdbc.OracleDriver",dialect:"org.hibernate.dialect.Oracle12cDialect",dependency:{groupId:"com.oracle.database.jdbc",artifactId:"ojdbc11",version:"23.3.0.23.09"}}:e.startsWith("jdbc:sqlserver:")?{driver:"com.microsoft.sqlserver.jdbc.SQLServerDriver",dialect:"org.hibernate.dialect.SQLServer2012Dialect",dependency:{groupId:"com.microsoft.sqlserver",artifactId:"mssql-jdbc",version:"12.6.1.jre11"}}:e.startsWith("jdbc:h2:")?{driver:"org.h2.Driver",dialect:"org.hibernate.dialect.H2Dialect",dependency:{groupId:"com.h2database",artifactId:"h2",version:"2.2.224"}}:e.startsWith("jdbc:derby:")?{driver:"org.apache.derby.jdbc.EmbeddedDriver",dialect:"org.hibernate.dialect.DerbyDialect",dependency:{groupId:"org.apache.derby",artifactId:"derby",version:"10.15.2.0"}}:e.startsWith("jdbc:db2:")?{driver:"com.ibm.db2.jcc.DB2Driver",dialect:"org.hibernate.dialect.DB2Dialect",dependency:{groupId:"com.ibm.db2",artifactId:"jcc",version:"11.5.8.0"}}:e.startsWith("jdbc:firebird:")?{driver:"org.firebirdsql.jdbc.FBDriver",dialect:"org.hibernate.dialect.FirebirdDialect",dependency:{groupId:"org.firebirdsql.jdbc",artifactId:"jaybird-jdk18",version:"4.0.3"}}:e.startsWith("jdbc:sybase:")?{driver:"com.sybase.jdbc4.jdbc.SybDriver",dialect:"org.hibernate.dialect.SybaseDialect",dependency:{groupId:"com.sybase",artifactId:"jconn4",version:"7.07"}}:{driver:"",dialect:"",dependency:null}}getDataType(e){if(null==e)return"String";switch(e.toUpperCase()){case"CHAR":case"VARCHAR":case"TEXT":case"LONGTEXT":case"MEDIUMTEXT":default:return"String";case"TINYINT":case"SMALLINT":case"MEDIUMINT":case"INT":return"Integer";case"BIGINT":return"Long";case"FLOAT":return"Float";case"DOUBLE":case"DECIMAL":return"Double";case"BOOLEAN":return"Boolean";case"DATE":return"Date";case"DATETIME":case"TIMESTAMP":return"DateTime"}}getFilterType(e){return null==e||"String"===e?"partial":"exact"}}